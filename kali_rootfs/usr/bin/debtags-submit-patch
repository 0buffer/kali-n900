#!/usr/bin/python3

# debtags-submit-patch: submit a tag patch to the debtags website
#
# Copyright (C) 2007--2012  Enrico Zini <enrico@debian.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import pwd
import os
import sys
import hashlib
import urllib
import urllib2
import json
import logging

log = logging.getLogger(sys.argv[0])

SUBMIT_URL = "http://debtags.debian.net/api/patch"

def make_default_tag():
    "Autogenerate a mostly persistant, non-trackable tag"
    m = hashlib.md5()
    m.update(":".join(str(x) for x in pwd.getpwuid(os.getuid())))
    return m.hexdigest()[:20]

def submit(opts, patch, fname="[stdin]"):
    log.info("Submitting patch %s to %s...", fname, opts.url)
    try:
        conn = urllib2.urlopen(opts.url,
                               urllib.urlencode((
                                  ("tag", opts.tag),
                                  ("patch", patch),
                               )))
        res = json.load(conn)
        for note in res.get("notes", ()):
            log.warn("%s: %s", fname, note)

        for pkg, tags in sorted(res.get("pkgs", {}).iteritems()):
            log.info("%s: %s: %s", fname, pkg, ", ".join(tags))

        if opts.dump_http_error:
            try:
                os.unlink(opts.dump_http_error)
            except OSError:
                pass
    except urllib2.HTTPError, e:
        log.error("%s", str(e))
        if opts.dump_http_error:
            with open(opts.dump_http_error, "w") as fd:
                fd.write(e.read())


if __name__ == "__main__":
    from optparse import OptionParser
    import sys

    VERSION="1.8"

    class Parser(OptionParser):
        def print_help(self, out=None):
            if out is None: out = sys.stdout
            OptionParser.print_help(self, out)
            print >>out, """Patch files can be generated with 'debtags diff' or 'tagcoll diff'.

Patch submissions are marked with a tag of your choice. It does not need to
identify yourself (but feel free to use your email address), but reusing your
tag allows to handle all your edits as if they were a single one. This helps
greatly when tags are reviewed.

By default, a mostly persistent but anonymous tag is generated by hashing your
passwd entry.
"""
        def error(self, msg):
            sys.stderr.write("%s: error: %s\n\n" % (self.get_prog_name(), msg))
            self.print_help(sys.stderr)
            sys.exit(2)

    parser = Parser(usage="usage: %prog [-t TAG] [options] [patchfile [patchfile...]]",
                    version="%prog "+ VERSION,
                    description="Submits a tag patch to the Debtags website."
                    " Each patch file is submitted in a different query.")
    parser.add_option("-t", "--tag", action="store", metavar="tag", default=make_default_tag(),
                      help="tag the patch with the given string (default: %default).")
    parser.add_option("-q", "--quiet", action="store_true",
                      help="quiet mode: only output errors.")
    parser.add_option("-v", "--verbose", action="store_true",
                      help="verbose mode: output progress and non-essential information.")
    parser.add_option("--stdin", action="store_true",
                      help="read patch from standard input.")
    parser.add_option("--url", action="store", metavar="url", default=SUBMIT_URL,
                      help="URL to submit to (default: %default).")
    parser.add_option("--dump-http-error", action="store", metavar="file",
                      help="if the server returns an error, dump the contents"
                           "of the error page to the given file (default:"
                           "discard the error page).")
    (opts, args) = parser.parse_args()

    #FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
    FORMAT = "%(message)s"
    if opts.quiet:
        logging.basicConfig(level=logging.ERROR, stream=sys.stderr, format=FORMAT)
    elif not opts.verbose:
        logging.basicConfig(level=logging.WARNING, stream=sys.stderr, format=FORMAT)
    else:
        logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)

    if opts.stdin:
        patch = sys.stdin.read()
        submit(opts, patch)
    elif args:
        for fname in args:
            with open(fname, "r") as fd:
                patch = fd.read()
            submit(opts, patch, fname)
    else:
        parser.error("please invoke with a patch file name or use --stdin.")
